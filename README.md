# Домашнее задание по теме «JVM. Организация памяти, сборщики мусора, VisualVM»

## Задача 1 (обязательная)

Просмотрите код ниже и опишите каждую строку с точки зрения происходящего в JVM:

```java
public class JvmComprehension {                                 // 1
    public static void main(String[] args) {                    // 2
        int i = 1;                                              // 3
        Object o = new Object();                                // 4
        Integer ii = 2;                                         // 5
        printAll(o, i, ii);                                     // 6
        System.out.println("finished");                         // 9
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                               // 7
        System.out.println(o.toString() + i + ii);              // 8
    }
}                                                               // 10
```

### Описание кода с точки зрения происходящего в JVM:

1. `ClassLoader` подгружает все необходимые системные классы в `Metaspace`
и загружает мета-данные класса `JvmComprehension`;

2. В `Stack` создаётся фрейм для метода `main()`;

3. Локальная переменная со своим значением `i = 1` помещается в `Stack` во фрейм `main()`;

4. В `Heap` создается объект класса `Object`, а ссылка `o` на созданный объект в `Heap` помещается в `Stack` во фрейм `main()`;

5. В `Heap` создается объект класса `Integer` который инициализируется значением `2`. Ссылка `ii` на созданный объект в `Heap`
помещается в `Stack` во фрейм `main()`;

6. В `Stack` создаётся новый фрейм для метода `printAll()`. В этот фрейм помещаются:

* ссылка `o` на ранее созданный `Object` в `Heap`,
* локальная переменная `i = 1`,
* ссылка `ii` на ранее созданный `Integer` в `Heap`;

7. В `Heap` создается объект класса `Integer` который инициализируется значением `700`.                                    
Ссылка `uselessVar` на созданный объект в `Heap` помещается в `Stack` во фрейм `printAll`;

8. Для каждого из полей `o`, `i` и `ii` вызывается метод `toString()`. 
Для каждого такого вызова создается отдельный фрейм в `Stack`, который удаляется из `Stack` после выполнения этих методов.
В `Heap` выделяется память под новый объект класса `String` в который заносится результат конкатенации строк.
В `Stack` создаётся новый фрейм для метода `println()`. Ссылка на созданный объект помещается во фрейм `println`.
После выполнения метода `println()` фрейм удаляется из `Stack`. Новый объект типа `String` может быть удалён из `Heap` при следующем
запуске `Сборщика мусора`, т.к. отсутствует ссылка на данный объект.
После выполнение метода `printAll()` фрейм удаляется из `Stack`;

9. В `Heap` создается объект класса `String`, который инициализируется значением `finished`.
В `Stack` создаётся новый фрейм для метода `println()`. Ссылка на созданный объект помещается во фрейм `println`.
После выполнения метода `println()` фрейм удаляется. 

10. Программа завершается Сборщик мусора чистит `Heap`, удаляются все ссылки и очищяется стек.
